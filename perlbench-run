#!/usr/bin/perl -w

# $Id$

require 5.002;
use strict;
$| = 1;

my $VERBOSE;

use Getopt::Std;
use vars qw($opt_v $opt_c $opt_t $opt_s);
getopts("vc:t:s") or usage();

$VERBOSE = $opt_v;

my @perls;
for (@ARGV) {
    eval {
	push(@perls, Perl->new($_));
    };
    if ($@) {
	$@ =~ s/ at (.*) line (\d+).*\n//;
	warn "$@, skipping...\n";
    }
}

usage() unless @perls;

# Show perl configurations
{
    my %cnf;
    my $keymax = length("version");
    for my $p (@perls) {
	while (my($k,$v) = each %{$p->{config} || {}}) {
	    $cnf{$k}{$v}++;
	    $keymax = length($k) if length($k) > $keymax;
	}
    }

    for my $p (@perls) {
	print "$p->{label}) $p->{fullname}\n";
	printf "\t%-*s = %s\n", $keymax, "version", $p->{version};
	printf "\t%-*s = %s\n", $keymax, "path", $p->{path};
	for my $k (sort keys %{$p->{config} || {}}) {
	    printf "\t%-*s = %s\n", $keymax, $k, $p->{config}{$k}
		unless $cnf{$k}{$p->{config}{$k}} == @perls;
	}
	print "\n";
    }
}


my $factor = $opt_c;
unless ($factor) {
    $factor = `$^X cpu_factor`;
    chomp($factor);
    die "Can't calculate cpu speed factor" unless $factor;
}

print "\nCPU SPEED FACTOR = $factor\n" if $VERBOSE;

# Try to run tests
die "No test directory found" unless -d 't';

my @tests;

use File::Find;
find(sub { /\.t$/ && push(@tests, $File::Find::name) }, "t");
if ($opt_t) {
    @tests = grep /$opt_t/o, @tests;
}
@tests = sort @tests;

# Try to run the empty test in order to time the loop
for my $p (@perls) {
    print "Timing empty loop for perl-$p->{version}\n" if $VERBOSE;
    $p->run_cmd(*P, "empty.t", $factor);
    while (<P>) {
        next unless /^CYCLES\/SEC:\s*(\S+)/;
        $p->{empty_cycles} = int($1);
	print if $VERBOSE;
    }
    close(P);
    die "Could not determine empty test speed for $p->{path}"
        unless  $p->{empty_cycles};
    $p->{point_sum} = 0;
}

unless ($VERBOSE) {
    print "\n";
    print " " x 20;
    for my $p (@perls) {
	printf "%8s", $p->{label};
    }
    print "\n";

    print " " x 20;
    for my $p (@perls) {
	printf "%8s", ("-" x max(3, length($p->{label})));
    }
    print "\n";
}

my $test;
for $test (@tests) {
    unless (open(T, $test)) {
	warn "Can't open $test: $!";
	next;
    }
    my %prop;
    my $lines = 20;
    while (<T>) {
	last unless $lines--;
	next unless /^\#\s*(\w+)\s*:\s*(.*)/;
	my($k,$v) = (lc($1), $2);

	if (defined $prop{$k}) {
	    $prop{$k} .= "\n$v";
	} else {
	    $prop{$k} = $v;
	}
    }
    close(T);

    if ($VERBOSE) {
        print "Test properties:\n";
	for (keys %prop) {
	    print "\t$_ = $prop{$_}\n";
	}
    }

    my $name = $test;
    $name =~ s,^t/,,;
    $name =~ s,\.t$,,;
    printf "%-20s", $name unless $VERBOSE;

    my $scale;
    my $p;
    for my $p (@perls) {
	if ($p->{version} < $prop{'require'}) {
	    # Can't run test
	    if ($VERBOSE) {
		print "Perl-$p->{version} can't run the test\n";
	    } else {
		printf "%8s", "N/A";
	    }
	    next;
	}
	my $points = 0;
	$p->run_cmd(*P, $test, $factor, $p->{empty_cycles});
	while (<P>) {
	    print ">>> $_" if $VERBOSE;
	    if (/^BENCH POINTS:\s+(\S+)/) {
		$points = $1;
	    }
	}
	close(P);

	unless ($VERBOSE) {
	    # present results
	    unless ($opt_s) {
		unless (defined $scale) {
		    $scale = 100 / $points;
		}
		$points *= $scale;
	    }
	    printf "%8.0f", $points;
	    $p->{point_sum} += $points;
	    $p->{no_tests}++;
	}
    }
    print "\n" unless $VERBOSE;
}

unless ($VERBOSE) {
    print "\n";
    printf "%-20s", "AVERAGE";
    for my $p (@perls) {
        printf "%8.0f", $p->{point_sum} / $p->{no_tests};
    }
    print "\n";
}


sub usage
{
    $0 =~ s,.*/,,;
    die "Usage: $0 [options] [lab1=]<perl1> [lab2=]<perl2>...

Recognized options:
  -v               more verbose output
  -s               don't scale numbers (so that first perl is always 100)
  -t <filter>      only tests that match <filter> regex are timed
  -c <cpu-factor>  use this factor to scale tests instead of running the
                   'cpu_factor' program to determine it.
";
}

sub max
{
    my $max = shift;
    while (@_) {
	my $n = shift;
	$max = $n if $n > $max;
    }
    return $max;
}

BEGIN {
package Perl;

my $NEXT_LABEL = "A";

sub new
{
    my($class, $path) = @_;
    my $label;
    if ($path =~ s/^(\S+)=//) {
	$label = $1;
    }
    else {
	$label = $NEXT_LABEL++;
    }
    unless (-x $path) {
	die "$path is not executable";
	next;
    }
    my $self = bless { path => $path, label => $label }, $class;
    $self->run_cmd(*V, '-e', 'print qq(This is perl ), $]+0, qq(\n)');
    my $version = <V>;
    close V or die "closing pipe from perl: exit code $?";
    chomp $version;
    unless ($version =~ /^This is perl (\d+.\d+)/) {
	die "$path does not appear to be a working perl";
    }
    $self->{version} = $1;
    $self->run_cmd(*V, '-v');
    while (<V>) {
	if (/^This is perl, v(\S+)/) {
	    $self->{fullname} = "perl-$1";
	}
	if (/^Binary build (\d+.*) provided by ActiveState/) {
	    $self->{fullname} .= " build $1";
	    $self->{fullname} =~ s/^perl/ActivePerl/;
	}
    }
    close(V);

    if ($self->{version} >= 5) {
	# The perl should have Configure support.  Try to extract
	# some key settings
	my $prog = 'use Config; Config::config_vars(qw(cc ccversion gccversion optimize ccflags usethreads use64bitint use64bitall usemymalloc))';
	$self->run_cmd(*CONFIG, '-e', $prog);
	while (<CONFIG>) {
	   next unless /^(\w+)='([^']+)'/;  #' #
           $self->{config}{$1} = $2;
        }
	close(CONFIG);
    }
    return $self;
}

my $ld_path = Cwd::extLibpath()	 if $^O eq 'os2';
$ld_path .= ';'			 if $ld_path and $^O eq 'os2';

sub cmd
{
    my $self = shift;
    my $path = $self->{path};
    (my $pdir = $path) =~ s,[/\\][^/\\]+$,/,;
    if (-d "$pdir/lib") {
        # uninstalled perl
        Cwd::extLibpath_set("$ld_path$pdir") if $^O eq 'os2'; # Find DLL
	($path, '-I', "$pdir/lib");
    } else {
	$path;
    }
}

sub run_cmd
{
    my $self = shift;
    my @cmd = $self->cmd;
    my $fh = shift;
    my @args = map {/\s/ ? "'$_'" : $_} @_;
    print "Running '@cmd @args'...\n" if $VERBOSE;
    open($fh, "@cmd @args |") or die "Cannot pipe from '@cmd @args': $!";
}

}
